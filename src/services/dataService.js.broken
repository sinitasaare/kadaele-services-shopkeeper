import localforage from 'localforage';

// Configure localforage
localforage.config({
  name: 'kadaele-pos',
  storeName: 'pos_data',
});

// Cloud API Configuration
const API_BASE_URL = 'https://kadaele-services-shopkeeper.onrender.com/api';

// Get token from localStorage (set during login)
const getAuthToken = () => {
  return localStorage.getItem('auth_token');
};

// Data file keys
const DATA_KEYS = {
  GOODS: 'goods',
  PURCHASES: 'purchases',
  DEBTORS: 'debtors',
  INVENTORY: 'inventory',
  SYNC_QUEUE: 'sync_queue',
  LAST_SYNC: 'last_sync',
  LAST_CLOUD_SYNC: 'last_cloud_sync',
};

class DataService {
  constructor() {
    this.isOnline = navigator.onLine;
    this.syncInProgress = false;
    
    // Listen for online/offline events
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.syncFromCloud(); // Sync products when coming online
    });

    window.addEventListener('offline', () => {
      this.isOnline = false;
    });

    // Initialize cloud products on startup
    this.initializeCloudProducts();
  }

  // NEW: Fetch products from cloud backend
  async fetchProductsFromCloud() {
    const token = getAuthToken();
    if (!token) {
      console.log('âš ï¸ No auth token - user needs to login');
      return [];
    }

    try {
      const response = await fetch(`${API_BASE_URL}/products/`, {
        headers: { 'Authorization': `Token ${token}` }
      });
      
      if (!response.ok) {
        if (response.status === 401) {
          console.log('âš ï¸ Token invalid - user needs to re-login');
          return [];
        }
        throw new Error('Failed to fetch from cloud');
      }

      const data = await response.json();
      return data.results || [];
    } catch (error) {
      console.error('Cloud fetch error:', error);
      return [];
    }
  }

  // NEW: Initialize products from cloud
  async initializeCloudProducts() {
    const goods = await this.getGoods();

    // Always sync if no products, or force sync every time when online
    if (goods.length === 0) {
      console.log('ðŸ“¦ No products found - syncing from cloud...');
      if (navigator.onLine) {
        await this.syncFromCloud();
      }
    } else if (navigator.onLine) {
      // Also check for updates in background
      console.log('ðŸ”„ Checking for product updates...');
      this.syncFromCloud(); // Don't await - happens in background
    }
  }

  // NEW: Sync products from cloud to local storage
  async syncFromCloud() {
    if (!this.isOnline) return { success: false, message: 'Offline' };

    try {
      const cloudProducts = await this.fetchProductsFromCloud();
      
      if (cloudProducts && cloudProducts.length > 0) {
        await this.setGoods(cloudProducts);
        await localforage.setItem(DATA_KEYS.LAST_CLOUD_SYNC, new Date().toISOString());
        console.log(`âœ… Synced ${cloudProducts.length} products from cloud`);
        return { success: true, count: cloudProducts.length };
      }
      
      return { success: false, message: 'No products from cloud' };
    } catch (error) {
      console.error('Cloud sync error:', error);
      return { success: false, error: error.message };
    }
  }

  // Generate unique ID
  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // Get current server time (or local time if offline)
  async getServerTime() {
    if (navigator.onLine) {
      try {
        const response = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC');
        const data = await response.json();
        return new Date(data.datetime);
      } catch (error) {
        console.warn('Could not get server time, using local time:', error);
        return new Date();
      }
    }
    return new Date();
  }

  // Generic CRUD operations
  async get(key) {
    try {
      const data = await localforage.getItem(key);
      return data || (key === DATA_KEYS.GOODS || key === DATA_KEYS.PURCHASES ||
                      key === DATA_KEYS.DEBTORS || key === DATA_KEYS.INVENTORY ? [] : null);
    } catch (error) {
      console.error(`Error getting ${key}:`, error);
      return key === DATA_KEYS.GOODS || key === DATA_KEYS.PURCHASES ||
             key === DATA_KEYS.DEBTORS || key === DATA_KEYS.INVENTORY ? [] : null;
    }
  }

  async set(key, value) {
    try {
      await localforage.setItem(key, value);
      // Add to sync queue if not already syncing
      await this.addToSyncQueue({ key, value, timestamp: Date.now() });
      return true;
    } catch (error) {
      console.error(`Error setting ${key}:`, error);
      return false;
    }
  }


  async setGoods(goods) {
    return await this.set(DATA_KEYS.GOODS, goods);
  }

  async addGood(good) {
    const goods = await this.getGoods();
    const newGood = {
      id: good.id || this.generateId(),
      name: good.name,
      price: parseFloat(good.price),
      category: good.category || 'General',
      barcode: good.barcode || null,
      createdAt: await this.getServerTime(),
    };
    goods.push(newGood);
    await this.setGoods(goods);
    return newGood;
  }

  async updateGood(id, updates) {
    const goods = await this.getGoods();
    const index = goods.findIndex(g => g.id === id);
    if (index !== -1) {
      goods[index] = { ...goods[index], ...updates };
      await this.setGoods(goods);
      return goods[index];
    }
    return null;
  }

  // [REST OF THE FILE REMAINS EXACTLY THE SAME - All purchase, debtor, inventory, sync, photo operations stay unchanged]
  
  async getPurchases() {
    return await this.get(DATA_KEYS.PURCHASES);
  }

  async setPurchases(purchases) {
    return await this.set(DATA_KEYS.PURCHASES, purchases);
  }

  async addPurchase(purchase) {
    const purchases = await this.getPurchases();
    const serverTime = await this.getServerTime();

    const newPurchase = {
      id: purchase.id || this.generateId(),
      date: serverTime.toISOString(),
      items: purchase.items,
      total: parseFloat(purchase.total),
      paymentType: purchase.paymentType,
      customerName: purchase.customerName || '',
      customerPhone: purchase.customerPhone || '',
      status: purchase.status || 'active',
      photoUrl: purchase.photoUrl || null,
      refund: purchase.refund || null,
      createdAt: serverTime.toISOString(),
    };

    purchases.push(newPurchase);
    await this.setPurchases(purchases);

    if (newPurchase.paymentType === 'credit' && newPurchase.customerName) {
      await this.updateDebtor(newPurchase);
    }

    return newPurchase;
  }

  async updatePurchase(id, updates) {
    const purchases = await this.getPurchases();
    const index = purchases.findIndex(p => p.id === id);

    if (index !== -1) {
      const purchase = purchases[index];
      const createdDate = new Date(purchase.createdAt);
      const now = new Date();
      const hoursDiff = (now - createdDate) / (1000 * 60 * 60);

      if (hoursDiff > 24 && !updates.allowAfter24Hours) {
        throw new Error('Cannot edit purchase after 24 hours');
      }

      purchases[index] = { ...purchase, ...updates };
      await this.setPurchases(purchases);

      if (purchases[index].paymentType === 'credit') {
        await this.recalculateDebtors();
      }

      return purchases[index];
    }
    return null;
  }

  async voidPurchase(id, reason) {
    return await this.updatePurchase(id, {
      status: 'voided',
      voidReason: reason,
      voidedAt: (await this.getServerTime()).toISOString(),
      allowAfter24Hours: true,
    });
  }

  async refundPurchase(id, amount, reason) {
    const purchase = await this.updatePurchase(id, {
      status: 'refunded',
      refund: {
        amount: parseFloat(amount),
        reason: reason,
        date: (await this.getServerTime()).toISOString(),
      },
      allowAfter24Hours: true,
    });

    if (purchase && purchase.paymentType === 'credit') {
      await this.recalculateDebtors();
    }

    return purchase;
  }

  async getDebtors() {
    return await this.get(DATA_KEYS.DEBTORS);
  }

  async setDebtors(debtors) {
    return await this.set(DATA_KEYS.DEBTORS, debtors);
  }

  async updateDebtor(purchase) {
    const debtors = await this.getDebtors();
    const existingDebtor = debtors.find(
      d => d.customerPhone === purchase.customerPhone ||
           d.customerName.toLowerCase() === purchase.customerName.toLowerCase()
    );

    if (existingDebtor) {
      existingDebtor.totalDue += purchase.total;
      existingDebtor.balance = existingDebtor.totalDue - existingDebtor.totalPaid;
      existingDebtor.purchaseIds.push(purchase.id);
      existingDebtor.lastPurchase = purchase.date;
    } else {
      debtors.push({
        id: this.generateId(),
        customerName: purchase.customerName,
        customerPhone: purchase.customerPhone,
        totalDue: purchase.total,
        totalPaid: 0,
        balance: purchase.total,
        purchaseIds: [purchase.id],
        createdAt: purchase.date,
        lastPurchase: purchase.date,
      });
    }

    await this.setDebtors(debtors);
  }

  async recordPayment(debtorId, amount, purchaseIds = []) {
    const debtors = await this.getDebtors();
    const debtor = debtors.find(d => d.id === debtorId);

    if (debtor) {
      const paymentAmount = parseFloat(amount);
      debtor.totalPaid += paymentAmount;
      debtor.balance = debtor.totalDue - debtor.totalPaid;
      debtor.lastPayment = (await this.getServerTime()).toISOString();

      if (purchaseIds.length > 0) {
        const purchases = await this.getPurchases();
        purchaseIds.forEach(pid => {
          const purchase = purchases.find(p => p.id === pid);
          if (purchase) {
            purchase.paid = true;
            purchase.paidDate = debtor.lastPayment;
          }
        });
        await this.setPurchases(purchases);
      }

      await this.setDebtors(debtors);
      return debtor;
    }
    return null;
  }

  async recalculateDebtors() {
    const purchases = await this.getPurchases();
    const creditPurchases = purchases.filter(
      p => p.paymentType === 'credit' && p.status === 'active'
    );

    const debtorsMap = new Map();

    creditPurchases.forEach(purchase => {
      const key = purchase.customerPhone || purchase.customerName;
      if (!debtorsMap.has(key)) {
        debtorsMap.set(key, {
          id: this.generateId(),
          customerName: purchase.customerName,
          customerPhone: purchase.customerPhone,
          totalDue: 0,
          totalPaid: 0,
          balance: 0,
          purchaseIds: [],
          createdAt: purchase.date,
          lastPurchase: purchase.date,
        });
      }

      const debtor = debtorsMap.get(key);
      debtor.totalDue += purchase.total;
      debtor.purchaseIds.push(purchase.id);
      if (new Date(purchase.date) > new Date(debtor.lastPurchase)) {
        debtor.lastPurchase = purchase.date;
      }
    });

    const debtors = Array.from(debtorsMap.values());
    const existingDebtors = await this.getDebtors();
    debtors.forEach(debtor => {
      const existing = existingDebtors.find(
        d => d.customerPhone === debtor.customerPhone ||
             d.customerName === debtor.customerName
      );
      if (existing) {
        debtor.totalPaid = existing.totalPaid;
        debtor.lastPayment = existing.lastPayment;
      }
      debtor.balance = debtor.totalDue - debtor.totalPaid;
    });

    await this.setDebtors(debtors);
  }

  async getInventory() {
    return await this.get(DATA_KEYS.INVENTORY);
  }

  async setInventory(inventory) {
    return await this.set(DATA_KEYS.INVENTORY, inventory);
  }

  async updateInventoryItem(itemId, stockLevel) {
    const inventory = await this.getInventory();
    const existing = inventory.find(i => i.itemId === itemId);

    if (existing) {
      existing.stockLevel = parseInt(stockLevel);
      existing.lastUpdated = (await this.getServerTime()).toISOString();
    } else {
      inventory.push({
        itemId: itemId,
        stockLevel: parseInt(stockLevel),
        lastUpdated: (await this.getServerTime()).toISOString(),
      });
    }

    await this.setInventory(inventory);
  }

  async addToSyncQueue(item) {
    const queue = await localforage.getItem(DATA_KEYS.SYNC_QUEUE) || [];
    queue.push(item);
    await localforage.setItem(DATA_KEYS.SYNC_QUEUE, queue);

    if (this.isOnline && !this.syncInProgress) {
      this.syncToServer();
    }
  }

  async syncToServer() {
    if (this.syncInProgress || !this.isOnline) return;

    this.syncInProgress = true;
    const queue = await localforage.getItem(DATA_KEYS.SYNC_QUEUE) || [];

    if (queue.length === 0) {
      this.syncInProgress = false;
      return { success: true, synced: 0 };
    }

    try {
      console.log('Syncing to server:', queue.length, 'items');
      await localforage.setItem(DATA_KEYS.SYNC_QUEUE, []);
      await localforage.setItem(DATA_KEYS.LAST_SYNC, new Date().toISOString());

      this.syncInProgress = false;
      return { success: true, synced: queue.length };
    } catch (error) {
      console.error('Sync failed:', error);
      this.syncInProgress = false;
      return { success: false, error: error.message };
    }
  }

  async getLastSyncTime() {
    return await localforage.getItem(DATA_KEYS.LAST_SYNC);
  }

  async savePhoto(photoData, purchaseId) {
    try {
      const photoKey = `photo_${purchaseId}`;
      await localforage.setItem(photoKey, photoData);

      if (navigator.onLine) {
        console.log('Uploading photo for purchase:', purchaseId);
      }

      return photoKey;
    } catch (error) {
      console.error('Error saving photo:', error);
      throw error;
    }
  }

  async getPhoto(photoKey) {
    return await localforage.getItem(photoKey);
  }
}

export default new DataService();
